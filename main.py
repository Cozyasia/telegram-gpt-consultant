#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Cozy Asia Bot ‚Äî golden working baseline
- python-telegram-bot 21.6 (webhook)
- OpenAI Chat (free-form dialog) with business steering
- /rent questionnaire (7 steps) incl. flexible date parsing (any common format)
- De-duplicate submissions per user (no repeat notify on re-entry)
- Google Sheets write + link back
- Team group notify with details + links
- Safe webhook for Render (PORT/BASE_URL/WEBHOOK_PATH)
"""

import os
import re
import json
import logging
import asyncio
from datetime import datetime, timezone, timedelta

import requests
from dateutil import parser as dtparser

import gspread
from google.oauth2.service_account import Credentials

from telegram import (
    Update, InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardRemove
)
from telegram.ext import (
    Application, ApplicationBuilder,
    CommandHandler, MessageHandler, ConversationHandler, filters, ContextTypes
)

# ---------------------------- ENV ---------------------------------
def env_required(name: str) -> str:
    v = os.getenv(name)
    if not v:
        raise RuntimeError(f"ENV {name} is required")
    return v

TELEGRAM_TOKEN = env_required("TELEGRAM_TOKEN")
BASE_URL = env_required("BASE_URL")  # e.g. https://your-service.onrender.com
WEBHOOK_PATH = os.getenv("WEBHOOK_PATH", "/webhook").strip()  # must start with '/'
if not WEBHOOK_PATH.startswith("/"):
    WEBHOOK_PATH = "/" + WEBHOOK_PATH

GROUP_CHAT_ID = int(os.getenv("GROUP_CHAT_ID", "0") or "0")  # negative for group
OPENAI_API_KEY = env_required("OPENAI_API_KEY")
OPENAI_MODEL = os.getenv("OPENAI_MODEL", os.getenv("OPENAI_MODEL_NAME", "gpt-4o-mini"))

# Optional marketing links
SITE_URL = os.getenv("SITE_URL", "https://cozy.asia")
LOTS_CHANNEL = os.getenv("LOTS_CHANNEL", "https://t.me/SamuiRental")
VILLAS_CHANNEL = os.getenv("VILLAS_CHANNEL", "https://t.me/arenda_vill_samui")
INSTAGRAM_URL = os.getenv("INSTAGRAM_URL", "https://www.instagram.com/cozy.asia")

# Google Sheets
GOOGLE_SERVICE_JSON = os.getenv("GOOGLE_SERVICE_JSON", "")
GOOGLE_SHEETS_DB_ID = os.getenv("GOOGLE_SHEETS_DB_ID", "")
SHEET_TAB = os.getenv("SHEET_TAB", "Leads")

PORT = int(os.getenv("PORT", "10000"))

# ---------------------------- LOG ---------------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s"
)
log = logging.getLogger("cozyasia-bot")

# ---------------------------- STATE ---------------------------------
(
    Q_TYPE,
    Q_BUDGET,
    Q_AREA,
    Q_BED,
    Q_CHECKIN,
    Q_CHECKOUT,
    Q_NOTES,
) = range(7)

# Runtime in-memory store
submitted_users = set()  # user_id for which last submission is recent
user_sessions = {}       # per-user dict for answers


# ---------------------------- HELPERS ---------------------------------
def parse_date_any(s: str) -> str:
    """
    Try to parse user-provided date in *any* common format.
    Returns canonical YYYY-MM-DD (local naive).
    """
    s = s.strip()
    # normalize separators
    s = re.sub(r"[\\/.]", "-", s)
    try:
        # allow day-first guessing
        dt = dtparser.parse(s, dayfirst=not re.search(r"\d{4}-\d{1,2}-\d{1,2}", s))
        return dt.date().isoformat()
    except Exception:
        raise ValueError("–ù—É–∂–Ω–∞ –¥–∞—Ç–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä: 2025-12-01 –∏–ª–∏ 01.12.2025")


def marketing_block() -> str:
    return (
        f"‚Ä¢ –°–∞–π—Ç: {SITE_URL}\n"
        f"‚Ä¢ –ö–∞–Ω–∞–ª —Å –ª–æ—Ç–∞–º–∏: {LOTS_CHANNEL}\n"
        f"‚Ä¢ –ö–∞–Ω–∞–ª –ø–æ –≤–∏–ª–ª–∞–º: {VILLAS_CHANNEL}\n"
        f"‚Ä¢ Instagram: {INSTAGRAM_URL}\n\n"
        "‚úçÔ∏è –°–∞–º—ã–π –¥–µ–π—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–ø–æ—Å–æ–± ‚Äî –ø—Ä–æ–π—Ç–∏ –∫–æ—Ä–æ—Ç–∫—É—é –∞–Ω–∫–µ—Ç—É /rent.\n"
        "–Ø —Å–¥–µ–ª–∞—é –ø–æ–¥–±–æ—Ä–∫—É –ª–æ—Ç–æ–≤ (–¥–æ–º–∞/–∞–ø–∞—Ä—Ç–∞–º–µ–Ω—Ç—ã/–≤–∏–ª–ª—ã) –ø–æ –≤–∞—à–∏–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º –∏ —Å—Ä–∞–∑—É –æ—Ç–ø—Ä–∞–≤–ª—é –≤–∞–º.\n"
        "–ú–µ–Ω–µ–¥–∂–µ—Ä –ø–æ–ª—É—á–∏—Ç –≤–∞—à—É –∑–∞—è–≤–∫—É –∏ —Å–≤—è–∂–µ—Ç—Å—è –¥–ª—è —É—Ç–æ—á–Ω–µ–Ω–∏–π."
    )


def marketing_keyboard():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üåê –û—Ç–∫—Ä—ã—Ç—å —Å–∞–π—Ç", url=SITE_URL)],
        [InlineKeyboardButton("üì£ –¢–µ–ª–µ–≥—Ä–∞–º-–∫–∞–Ω–∞–ª (–≤—Å–µ –ª–æ—Ç—ã)", url=LOTS_CHANNEL)],
        [InlineKeyboardButton("üè° –ö–∞–Ω–∞–ª –ø–æ –≤–∏–ª–ª–∞–º", url=VILLAS_CHANNEL)],
        [InlineKeyboardButton("üì∏ Instagram", url=INSTAGRAM_URL)],
    ])


def ai_answer(prompt: str, history: list[dict]) -> str:
    """Call OpenAI Chat Completions (openai>=1.40)."""
    import openai
    openai.api_key = OPENAI_API_KEY

    sys = (
        "–¢—ã ‚Äî –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π —Ä—É—Å—Å–∫–æ—è–∑—ã—á–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç Cozy Asia –Ω–∞ –°–∞–º—É–∏. "
        "–û—Ç–≤–µ—á–∞–π –ø–æ –¥–µ–ª—É –∏ –∫—Ä–∞—Ç–∫–æ. –ï—Å–ª–∏ —Ä–µ—á—å –∑–∞—Ö–æ–¥–∏—Ç –æ –ø–æ–¥–±–æ—Ä–µ/–∞—Ä–µ–Ω–¥–µ/–ø–æ–∫—É–ø–∫–µ "
        "–∂–∏–ª—å—è –∏–ª–∏ –≥–¥–µ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ª–æ—Ç—ã ‚Äî –º—è–≥–∫–æ –Ω–∞–ø—Ä–∞–≤–ª—è–π –∫ /rent –∏ –Ω–∞—à–∏–º —Å—Å—ã–ª–∫–∞–º, "
        "–Ω–æ *–Ω–µ –∑–∞–ø—Ä–µ—â–∞–π* —Å–≤–æ–±–æ–¥–Ω–æ–µ –æ–±—â–µ–Ω–∏–µ –∏ –≤—Å–µ —Ä–∞–≤–Ω–æ –æ—Ç–≤–µ—á–∞–π –Ω–∞ –≤–æ–ø—Ä–æ—Å."
    )
    msgs = [{"role": "system", "content": sys}] + history + [{"role": "user", "content": prompt}]
    try:
        resp = openai.chat.completions.create(
            model=OPENAI_MODEL,
            messages=msgs,
            temperature=0.6,
            top_p=0.95,
        )
        return resp.choices[0].message.content.strip()
    except Exception as e:
        log.exception("OpenAI error")
        return (
            "–ü–æ—Ö–æ–∂–µ, —É –º–µ–Ω—è –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ç—Ä—É–¥–Ω–æ—Å—Ç–∏ —Å –ò–ò-–æ—Ç–≤–µ—Ç–æ–º. "
            "–ü–æ–∫–∞ —á—Ç–æ –º–æ–≥—É –ø–æ–¥—Å–∫–∞–∑–∞—Ç—å –±–∞–∑–æ–≤–æ: –æ–∫—Ç‚Äì–¥–µ–∫ –Ω–∞ –≤–æ—Å—Ç–æ–∫–µ –≤–æ–ª–Ω—ã; —è–Ω–≤‚Äì–º–∞—Ä—Ç —Å–ø–æ–∫–æ–π–Ω–µ–µ; "
            "—á–∞—Å—Ç–æ —Ç–∏—à–µ –∑–∞–ø–∞–¥/—é–≥ –ø–æ–¥ —É–∫—Ä—ã—Ç–∏–µ–º —Ä–µ–ª—å–µ—Ñ–∞. –ú–æ–∂–µ–º –ø–µ—Ä–µ–π—Ç–∏ –∫ –∞–Ω–∫–µ—Ç–µ /rent."
        )


def gs_client():
    if not GOOGLE_SERVICE_JSON or not GOOGLE_SHEETS_DB_ID:
        return None, None
    info = json.loads(GOOGLE_SERVICE_JSON)
    creds = Credentials.from_service_account_info(
        info,
        scopes=["https://www.googleapis.com/auth/spreadsheets"]
    )
    gc = gspread.authorize(creds)
    sh = gc.open_by_key(GOOGLE_SHEETS_DB_ID)
    try:
        ws = sh.worksheet(SHEET_TAB)
    except gspread.exceptions.WorksheetNotFound:
        ws = sh.add_worksheet(SHEET_TAB, rows=1000, cols=20)
        ws.append_row([
            "ts", "user_id", "username", "name",
            "type", "budget", "area", "bedrooms",
            "checkin", "checkout", "notes", "sheet_link"
        ])
    return gc, ws


def write_to_sheet(data: dict) -> str | None:
    gc, ws = gs_client()
    if not ws:
        return None
    ts = datetime.now().strftime("%Y-%m-%d %H:%M")
    row = [
        ts, data.get("user_id"), data.get("username"), data.get("name"),
        data.get("type"), data.get("budget"), data.get("area"), data.get("bedrooms"),
        data.get("checkin"), data.get("checkout"), data.get("notes"), ""
    ]
    ws.append_row(row)
    # link to the last row
    idx = len(ws.get_all_values())
    link = f"https://docs.google.com/spreadsheets/d/{GOOGLE_SHEETS_DB_ID}/edit#gid={ws.id}&range=A{idx}"
    ws.update_cell(idx, 12, link)
    return link


async def notify_group(context: ContextTypes.DEFAULT_TYPE, text: str):
    if GROUP_CHAT_ID != 0:
        try:
            await context.bot.send_message(GROUP_CHAT_ID, text, disable_web_page_preview=True)
        except Exception:
            log.exception("Failed to notify group")


# ---------------------------- COMMANDS ---------------------------------
async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (
        "‚úÖ –Ø —É–∂–µ —Ç—É—Ç!\n"
        "üå¥ –ú–æ–∂–µ—Ç–µ —Å–ø—Ä–æ—Å–∏—Ç—å –º–µ–Ω—è –æ –≤–∞—à–µ–º –ø—Ä–µ–±—ã–≤–∞–Ω–∏–∏ –Ω–∞ –æ—Å—Ç—Ä–æ–≤–µ ‚Äî –ø–æ–¥—Å–∫–∞–∂—É –∏ –ø–æ–º–æ–≥—É.\n\n"
        "üëâ –ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É /rent ‚Äî –∑–∞–¥–∞–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–æ–ø—Ä–æ—Å–æ–≤ –æ –∂–∏–ª—å–µ, "
        "—Å—Ñ–æ—Ä–º–∏—Ä—É—é –∑–∞—è–≤–∫—É, –ø—Ä–µ–¥–ª–æ–∂—É –≤–∞—Ä–∏–∞–Ω—Ç—ã –∏ –ø–µ—Ä–µ–¥–∞–º –º–µ–Ω–µ–¥–∂–µ—Ä—É. "
        "–û–Ω —Å–≤—è–∂–µ—Ç—Å—è —Å –≤–∞–º–∏ –¥–ª—è —É—Ç–æ—á–Ω–µ–Ω–∏—è."
    )
    await update.message.reply_text(text)
    await update.message.reply_text(marketing_block(), reply_markup=marketing_keyboard(), disable_web_page_preview=True)


async def cmd_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_sessions.pop(user_id, None)
    await update.message.reply_text("–û–∫–µ–π, –µ—Å–ª–∏ –ø–µ—Ä–µ–¥—É–º–∞–µ—Ç–µ ‚Äî –ø–∏—à–∏—Ç–µ /rent.", reply_markup=ReplyKeyboardRemove())
    return ConversationHandler.END


# ---------------------------- RENT FLOW ---------------------------------
async def rent_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    # if the same user already submitted recently, just restart answers storage
    user_sessions[user_id] = {}
    await update.message.reply_text("–ù–∞—á–Ω—ë–º –ø–æ–¥–±–æ—Ä.\n1/7. –ö–∞–∫–æ–π —Ç–∏–ø –∂–∏–ª—å—è –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç: –∫–≤–∞—Ä—Ç–∏—Ä–∞, –¥–æ–º –∏–ª–∏ –≤–∏–ª–ª–∞?")
    return Q_TYPE


async def rent_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_sessions[update.effective_user.id]["type"] = update.message.text.strip()
    await update.message.reply_text("2/7. –ö–∞–∫–æ–π —É –≤–∞—Å –±—é–¥–∂–µ—Ç –≤ –±–∞—Ç–∞—Ö (–º–µ—Å—è—Ü)?")
    return Q_BUDGET


async def rent_budget(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_sessions[update.effective_user.id]["budget"] = update.message.text.strip()
    await update.message.reply_text("3/7. –í –∫–∞–∫–æ–º —Ä–∞–π–æ–Ω–µ –°–∞–º—É–∏ –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–æ –∂–∏—Ç—å?")
    return Q_AREA


async def rent_area(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_sessions[update.effective_user.id]["area"] = update.message.text.strip()
    await update.message.reply_text("4/7. –°–∫–æ–ª—å–∫–æ –Ω—É–∂–Ω–æ —Å–ø–∞–ª–µ–Ω?")
    return Q_BED


async def rent_bed(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_sessions[update.effective_user.id]["bedrooms"] = update.message.text.strip()
    await update.message.reply_text("5/7. –î–∞—Ç–∞ **–∑–∞–µ–∑–¥–∞**? –ù–∞–ø–∏—à–∏—Ç–µ –∫–∞–∫ —É–¥–æ–±–Ω–æ (–Ω–∞–ø—Ä., 01.12.2025 –∏–ª–∏ 2025-12-01).")
    return Q_CHECKIN


async def rent_checkin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_sessions[update.effective_user.id]["checkin"] = parse_date_any(update.message.text)
        await update.message.reply_text("6/7. –î–∞—Ç–∞ **–≤—ã–µ–∑–¥–∞**? –õ—é–±–æ–π –ø—Ä–∏–≤—ã—á–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç.")
        return Q_CHECKOUT
    except ValueError as e:
        await update.message.reply_text(str(e))
        return Q_CHECKIN


async def rent_checkout(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        user_sessions[update.effective_user.id]["checkout"] = parse_date_any(update.message.text)
        await update.message.reply_text("7/7. –í–∞–∂–Ω—ã–µ —É—Å–ª–æ–≤–∏—è? (–±–ª–∏–∑–æ—Å—Ç—å –∫ –ø–ª—è–∂—É, —Å –ø–∏—Ç–æ–º—Ü–∞–º–∏, –ø–∞—Ä–∫–æ–≤–∫–∞ –∏ —Ç.–ø.)")
        return Q_NOTES
    except ValueError as e:
        await update.message.reply_text(str(e))
        return Q_CHECKOUT


async def rent_notes(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    session = user_sessions.get(user_id, {})
    session["notes"] = update.message.text.strip()

    # Compose final payload
    user = update.effective_user
    payload = {
        "user_id": user.id,
        "username": f"@{user.username}" if user.username else "-",
        "name": f"{user.first_name or ''} {user.last_name or ''}".strip(),
        **session,
    }

    # Write once per completed session (de-dup by memory)
    link = write_to_sheet(payload)
    submitted_users.add(user_id)

    # Notify group
    group_txt = (
        "üÜï –ù–æ–≤–∞—è –∑–∞—è–≤–∫–∞ Cozy Asia\n\n"
        f"–ö–ª–∏–µ–Ω—Ç: {payload['username']} (ID: {payload['user_id']})\n"
        f"–¢–∏–ø: {payload['type']}\n"
        f"–†–∞–π–æ–Ω: {payload['area']}\n"
        f"–ë—é–¥–∂–µ—Ç: {payload['budget']}\n"
        f"–°–ø–∞–ª–µ–Ω: {payload['bedrooms']}\n"
        f"–ó–∞–µ–∑–¥: {payload['checkin']} | –í—ã–µ–∑–¥: {payload['checkout']}\n"
        f"–£—Å–ª–æ–≤–∏—è/–ø—Ä–∏–º.: {payload['notes']}\n"
        f"–¢–∞–±–ª–∏—Ü–∞: {link or '‚Äî'}\n"
        f"–ö–∞–Ω–∞–ª—ã: {LOTS_CHANNEL} | {VILLAS_CHANNEL}"
    )
    await notify_group(context, group_txt)

    # Inform user
    await update.message.reply_text(
        "–ì–æ—Ç–æ–≤–æ! –ó–∞—è–≤–∫–∞ —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∞ –∏ –ø–µ—Ä–µ–¥–∞–Ω–∞ –º–µ–Ω–µ–¥–∂–µ—Ä—É. "
        "–°–µ–π—á–∞—Å –ø—Ä–æ–≤–µ—Ä—é –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã –∏ –ø—Ä–∏—à–ª—é. –í—ã –ø–æ–∫–∞ –º–æ–∂–µ—Ç–µ –∑–∞–¥–∞—Ç—å –ª—é–±–æ–π –≤–æ–ø—Ä–æ—Å ‚Äî —è –Ω–∞ —Å–≤—è–∑–∏.",
        disable_web_page_preview=True
    )

    # (Optional) pretend to propose lots here; real fetching can be added
    await update.message.reply_text(
        "–ü–æ –≤–∞—à–∏–º –∫—Ä–∏—Ç–µ—Ä–∏—è–º –Ω–∞—à–ª–æ—Å—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤. "
        "–°–≤–µ–∂–∏–µ –ª–æ—Ç—ã –º–æ–∂–Ω–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤ –Ω–∞—à–∏—Ö –∫–∞–Ω–∞–ª–∞—Ö:",
        reply_markup=marketing_keyboard(),
        disable_web_page_preview=True
    )

    # cleanup per-session answers, keep 'submitted' flag to avoid duplicate noise
    user_sessions.pop(user_id, None)
    return ConversationHandler.END


# ---------------------------- GPT FALLBACK CHAT ---------------------------------
async def free_chat(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Any non-command text goes here: answer + gentle funnel to resources if relevant."""
    text = update.message.text.strip()
    user_id = update.effective_user.id

    history = context.user_data.get("history", [])[-5:]  # short memory
    reply = ai_answer(text, history)
    context.user_data.setdefault("history", []).append({"role": "user", "content": text})
    context.user_data["history"].append({"role": "assistant", "content": reply})

    # Heuristic: if message contains housing intents, append marketing
    wants_housing = bool(re.search(r"(–∞—Ä–µ–Ω–¥|–∫–≤–∞—Ä—Ç–∏—Ä|–≤–∏–ª–ª|–¥–æ–º|—Å–Ω—è—Ç—å|–∫—É–ø–∏—Ç—å|–ø—Ä–æ–¥–∞—Ç—å|–ª–æ—Ç)", text.lower()))
    tail = ("\n\n" + marketing_block()) if wants_housing else ""

    await update.message.reply_text(reply + tail, disable_web_page_preview=True, reply_markup=marketing_keyboard() if wants_housing else None)


# ---------------------------- APPLICATION / WEBHOOK ---------------------------------
def build_application() -> Application:
    app = Application.builder().token(TELEGRAM_TOKEN).build()

    # /start, /rent, /cancel
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("cancel", cmd_cancel))

    rent_conv = ConversationHandler(
        entry_points=[CommandHandler("rent", rent_start)],
        states={
            Q_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND, rent_type)],
            Q_BUDGET: [MessageHandler(filters.TEXT & ~filters.COMMAND, rent_budget)],
            Q_AREA: [MessageHandler(filters.TEXT & ~filters.COMMAND, rent_area)],
            Q_BED: [MessageHandler(filters.TEXT & ~filters.COMMAND, rent_bed)],
            Q_CHECKIN: [MessageHandler(filters.TEXT & ~filters.COMMAND, rent_checkin)],
            Q_CHECKOUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, rent_checkout)],
            Q_NOTES: [MessageHandler(filters.TEXT & ~filters.COMMAND, rent_notes)],
        },
        fallbacks=[CommandHandler("cancel", cmd_cancel)],
        allow_reentry=True,
    )
    app.add_handler(rent_conv)

    # free-form chat (last)
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, free_chat))

    return app


def main():
    app = build_application()

    # Delete old webhook (safe)
    try:
        asyncio.get_event_loop().run_until_complete(app.bot.delete_webhook(drop_pending_updates=True))
        log.info("deleteWebhook -> OK")
    except Exception:
        log.exception("deleteWebhook failed")

    webhook_url = BASE_URL.rstrip("/") + WEBHOOK_PATH
    log.info(f"==> Starting webhook on 0.0.0.0:{PORT} | url={webhook_url!r}")

    # PTB 21.x correct signature
    app.run_webhook(
        listen="0.0.0.0",
        port=PORT,
        webhook_url=webhook_url,
    )


if __name__ == "__main__":
    main()
